using System.Runtime.InteropServices;
using NUnit.Framework;
using ValveResourceFormat.Compression;

// These tests were generated by encoding using meshoptimizer C++ version

namespace Tests
{
    public partial class MeshOptimizerTest
    {
        // Test: BitGroups - 0/2/4/8 bit groups in one stream (16 vertices, stride 4)
        private static readonly byte[] kVertexBitGroupsExpected = [
            0, 0, 0, 0, 0, 1, 2, 8, 0, 2, 4, 16, 0, 3, 6, 24,
            0, 4, 8, 32, 0, 5, 10, 40, 0, 6, 12, 48, 0, 7, 14, 56,
            0, 8, 16, 64, 0, 9, 18, 72, 0, 10, 20, 80, 0, 11, 22, 88,
            0, 12, 24, 96, 0, 13, 26, 104, 0, 14, 28, 112, 0, 15, 30, 120
        ];

        private static readonly byte[] kVertexBitGroupsData = [
            0xa1, 0xd6, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x04, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: BitGroupSentinels - Bit groups with sentinel values at indices 7 and 13 (16 vertices, stride 4)
        private static readonly byte[] kVertexBitGroupSentinelsExpected = [
            0, 0, 0, 0, 0, 1, 2, 8, 0, 2, 4, 16, 0, 3, 6, 24,
            0, 4, 8, 32, 0, 5, 10, 40, 0, 6, 12, 48, 42, 42, 42, 42,
            0, 8, 16, 64, 0, 9, 18, 72, 0, 10, 20, 80, 0, 11, 22, 88,
            0, 12, 24, 96, 42, 42, 42, 42, 0, 14, 28, 112, 0, 15, 30, 120
        ];

        private static readonly byte[] kVertexBitGroupSentinelsData = [
            0xa1, 0xd5, 0x00, 0x80, 0x61, 0x54, 0x53, 0x54, 0x53, 0x01, 0x2a, 0xab, 0xea, 0xbe, 0x48, 0x43,
            0x3c, 0x37, 0x02, 0x04, 0x44, 0x44, 0x4f, 0xf4, 0x44, 0x4f, 0xf4, 0x3c, 0x33, 0x24, 0x1b, 0x00,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0b, 0x2c, 0x10, 0x10, 0x10, 0x10, 0x6b, 0x8c, 0x10, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: Deltas - Wider deltas crossing byte boundaries (16 vertices, stride 8, ushort values)
        private static readonly ushort[] kVertexDeltasExpected = [
            248, 248, 240, 240, 249, 250, 243, 244, 250, 252, 246, 248, 251, 254, 249, 252,
            252, 256, 252, 256, 253, 258, 255, 260, 254, 260, 258, 264, 255, 262, 261, 268,
            256, 264, 264, 272, 257, 266, 267, 276, 258, 268, 270, 280, 259, 270, 273, 284,
            260, 272, 276, 288, 261, 274, 279, 292, 262, 276, 282, 296, 263, 278, 285, 300
        ];

        private static readonly byte[] kVertexDeltasData = [
            0xa1, 0x99, 0x99, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x04, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x02, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x02, 0x08, 0x88, 0x88, 0x88, 0x88,
            0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0xf8, 0x00, 0xf8, 0x00, 0xf0, 0x00, 0xf0, 0x00, 0x01, 0x01
        ];

        // Test: BitXor - XOR encoding with bit-shifted values (16 vertices, stride 16, uint values)
        private static readonly uint[] kVertexBitXorExpected = [
            0, 0, 0, 0, 1, 4, 32768, 268435456, 2, 8, 65536, 536870912, 3, 12, 98304, 805306368,
            4, 16, 131072, 1073741824, 5, 20, 163840, 1342177280, 6, 24, 196608, 1610612736, 7, 28, 229376, 1879048192,
            8, 32, 262144, 2147483648, 9, 36, 294912, 2415919104, 10, 40, 327680, 2684354560, 11, 44, 360448, 2952790016,
            12, 48, 393216, 3221225472, 13, 52, 425984, 3489660928, 14, 56, 458752, 3758096384, 15, 60, 491520, 4026531840
        ];

        private static readonly byte[] kVertexBitXorData = [
            0xa1, 0xa9, 0xa9, 0x9a, 0xa9, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x08, 0x88, 0x88, 0x88, 0x88,
            0x88, 0x88, 0x88, 0x02, 0x01, 0x31, 0x71, 0x31, 0xf1, 0x31, 0x71, 0x31, 0x0f, 0x02, 0x01, 0x31,
            0x71, 0x31, 0xf1, 0x31, 0x71, 0x31, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x42
        ];

        // Test: Large - 128 vertices (larger than block size, stride 4)
        private static readonly byte[] kVertexLargeExpected = [
            0, 0, 0, 0, 0, 1, 2, 8, 0, 2, 4, 16, 0, 3, 6, 24,
            0, 4, 8, 32, 0, 5, 10, 40, 0, 6, 12, 48, 0, 7, 14, 56,
            0, 8, 16, 64, 0, 9, 18, 72, 0, 10, 20, 80, 0, 11, 22, 88,
            0, 12, 24, 96, 0, 13, 26, 104, 0, 14, 28, 112, 0, 15, 30, 120,
            0, 16, 32, 128, 0, 17, 34, 136, 0, 18, 36, 144, 0, 19, 38, 152,
            0, 20, 40, 160, 0, 21, 42, 168, 0, 22, 44, 176, 0, 23, 46, 184,
            0, 24, 48, 192, 0, 25, 50, 200, 0, 26, 52, 208, 0, 27, 54, 216,
            0, 28, 56, 224, 0, 29, 58, 232, 0, 30, 60, 240, 0, 31, 62, 248,
            0, 32, 64, 0, 0, 33, 66, 8, 0, 34, 68, 16, 0, 35, 70, 24,
            0, 36, 72, 32, 0, 37, 74, 40, 0, 38, 76, 48, 0, 39, 78, 56,
            0, 40, 80, 64, 0, 41, 82, 72, 0, 42, 84, 80, 0, 43, 86, 88,
            0, 44, 88, 96, 0, 45, 90, 104, 0, 46, 92, 112, 0, 47, 94, 120,
            0, 48, 96, 128, 0, 49, 98, 136, 0, 50, 100, 144, 0, 51, 102, 152,
            0, 52, 104, 160, 0, 53, 106, 168, 0, 54, 108, 176, 0, 55, 110, 184,
            0, 56, 112, 192, 0, 57, 114, 200, 0, 58, 116, 208, 0, 59, 118, 216,
            0, 60, 120, 224, 0, 61, 122, 232, 0, 62, 124, 240, 0, 63, 126, 248,
            0, 64, 128, 0, 0, 65, 130, 8, 0, 66, 132, 16, 0, 67, 134, 24,
            0, 68, 136, 32, 0, 69, 138, 40, 0, 70, 140, 48, 0, 71, 142, 56,
            0, 72, 144, 64, 0, 73, 146, 72, 0, 74, 148, 80, 0, 75, 150, 88,
            0, 76, 152, 96, 0, 77, 154, 104, 0, 78, 156, 112, 0, 79, 158, 120,
            0, 80, 160, 128, 0, 81, 162, 136, 0, 82, 164, 144, 0, 83, 166, 152,
            0, 84, 168, 160, 0, 85, 170, 168, 0, 86, 172, 176, 0, 87, 174, 184,
            0, 88, 176, 192, 0, 89, 178, 200, 0, 90, 180, 208, 0, 91, 182, 216,
            0, 92, 184, 224, 0, 93, 186, 232, 0, 94, 188, 240, 0, 95, 190, 248,
            0, 96, 192, 0, 0, 97, 194, 8, 0, 98, 196, 16, 0, 99, 198, 24,
            0, 100, 200, 32, 0, 101, 202, 40, 0, 102, 204, 48, 0, 103, 206, 56,
            0, 104, 208, 64, 0, 105, 210, 72, 0, 106, 212, 80, 0, 107, 214, 88,
            0, 108, 216, 96, 0, 109, 218, 104, 0, 110, 220, 112, 0, 111, 222, 120,
            0, 112, 224, 128, 0, 113, 226, 136, 0, 114, 228, 144, 0, 115, 230, 152,
            0, 116, 232, 160, 0, 117, 234, 168, 0, 118, 236, 176, 0, 119, 238, 184,
            0, 120, 240, 192, 0, 121, 242, 200, 0, 122, 244, 208, 0, 123, 246, 216,
            0, 124, 248, 224, 0, 125, 250, 232, 0, 126, 252, 240, 0, 127, 254, 248
        ];

        private static readonly byte[] kVertexLargeData = [
            0xa1, 0xd6, 0x55, 0x55, 0x2a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x04, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: Small - 13 vertices (unaligned count, stride 4)
        private static readonly byte[] kVertexSmallExpected = [
            0, 0, 0, 0, 0, 1, 2, 8, 0, 2, 4, 16, 0, 3, 6, 24,
            0, 4, 8, 32, 0, 5, 10, 40, 0, 6, 12, 48, 0, 7, 14, 56,
            0, 8, 16, 64, 0, 9, 18, 72, 0, 10, 20, 80, 0, 11, 22, 88,
            0, 12, 24, 96
        ];

        private static readonly byte[] kVertexSmallData = [
            0xa1, 0xd6, 0x01, 0x2a, 0xaa, 0xaa, 0x80, 0x02, 0x04, 0x44, 0x44, 0x44, 0x44, 0x44, 0x40, 0x00,
            0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: NegativeDeltas - int16 with negative deltas to trigger zigzag odd bit (16 vertices, stride 8)
        private static readonly short[] kVertexNegativeDeltasExpected = [
            1000, 2000, 500, 3000, 950, 1900, 475, 2850, 900, 1800, 450, 2700, 850, 1700, 425, 2550,
            800, 1600, 400, 2400, 750, 1500, 375, 2250, 700, 1400, 350, 2100, 650, 1300, 325, 1950,
            600, 1200, 300, 1800, 550, 1100, 275, 1650, 500, 1000, 250, 1500, 450, 900, 225, 1350,
            400, 800, 200, 1200, 350, 700, 175, 1050, 300, 600, 150, 900, 250, 500, 125, 750
        ];

        private static readonly byte[] kVertexNegativeDeltasData = [
            0xa1, 0xbb, 0x7b, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
            0x63, 0x63, 0x63, 0x00, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7,
            0xc7, 0xc7, 0xc7, 0x00, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
            0x31, 0x31, 0x31, 0x00, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
            0x2b, 0x2b, 0x2b, 0x01, 0x15, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xd0, 0x07, 0xf4, 0x01, 0xb8, 0x0b, 0x01, 0x01
        ];

        // Test: MixedDeltas - int16 with mixed positive/negative deltas (16 vertices, stride 8)
        private static readonly short[] kVertexMixedDeltasExpected = [
            100, 300, 500, 1000, 190, 165, -200, 940, 120, 270, -200, 880, 170, 195, 500, 820,
            140, 240, -200, 760, 150, 225, -200, 700, 160, 210, 500, 640, 130, 255, -200, 580,
            180, 180, -200, 520, 110, 285, 500, 460, 200, 150, -200, 400, 90, 315, -200, 340,
            220, 120, 500, 280, 70, 345, -200, 220, 240, 90, -200, 160, 50, 375, 500, 100
        ];

        private static readonly byte[] kVertexMixedDeltasData = [
            0xa1, 0x7b, 0xb5, 0x00, 0xb4, 0x8b, 0x64, 0x3b, 0x14, 0x14, 0x3b, 0x64, 0x8b, 0xb4, 0xdb, 0xfb,
            0xd4, 0xab, 0x84, 0x00, 0xf2, 0xd2, 0x95, 0x5a, 0x1d, 0x1d, 0x5a, 0x95, 0xd2, 0xf2, 0xb5, 0x7a,
            0x3d, 0x02, 0x3a, 0x01, 0x19, 0x00, 0x26, 0x66, 0x00, 0xda, 0xb6, 0x77, 0x78, 0x77, 0x78, 0x77,
            0x78, 0x77, 0x78, 0x77, 0x78, 0x02, 0x05, 0x05, 0x50, 0x55, 0x05, 0x50, 0x55, 0x05, 0x00, 0x77,
            0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x2c, 0x01,
            0xf4, 0x01, 0xe8, 0x03, 0x00, 0x01
        ];

        // Additional coverage tests - exercise all code paths

        // Test: HighRotation - uint32 with high bits for rotation testing (16 vertices, stride 16)
        private static readonly uint[] kVertexHighRotationExpected = [
            2147483648, 1073741824, 536870912, 268435456, 2147483649, 1073741826, 536870915, 268435460,
            2147483650, 1073741828, 536870918, 268435464, 2147483651, 1073741830, 536870921, 268435468,
            2147483652, 1073741832, 536870924, 268435472, 2147483653, 1073741834, 536870927, 268435476,
            2147483654, 1073741836, 536870930, 268435480, 2147483655, 1073741838, 536870933, 268435484,
            2147483656, 1073741840, 536870936, 268435488, 2147483657, 1073741842, 536870939, 268435492,
            2147483658, 1073741844, 536870942, 268435496, 2147483659, 1073741846, 536870945, 268435500,
            2147483660, 1073741848, 536870948, 268435504, 2147483661, 1073741850, 536870951, 268435508,
            2147483662, 1073741852, 536870954, 268435512, 2147483663, 1073741854, 536870957, 268435516
        ];

        private static readonly byte[] kVertexHighRotationData = [
            0xa1, 0xa9, 0xa9, 0xa9, 0xa9, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x04, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x02, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x02, 0x08, 0x88, 0x88,
            0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: SparsePattern - Sparse data to trigger literal encoding (16 vertices, stride 4)
        private static readonly byte[] kVertexSparsePatternExpected = [
            123, 231, 177, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 0,
            123, 0, 0, 0, 0, 231, 0, 0, 0, 0, 177, 0, 0, 0, 0, 99,
            123, 0, 0, 0, 0, 0, 177, 0, 0, 231, 0, 0, 0, 0, 0, 0,
            123, 0, 177, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 231, 177, 0
        ];

        private static readonly byte[] kVertexSparsePatternData = [
            0xa1, 0x55, 0x00, 0x32, 0x33, 0xf5, 0xf6, 0xf5, 0xf6, 0xf5, 0xf6, 0xf5, 0x00, 0x62, 0x8c, 0x32,
            0x31, 0x32, 0x31, 0x32, 0x31, 0x00, 0xda, 0xb6, 0x9e, 0x9d, 0x9e, 0x9d, 0x9e, 0x9d, 0x9e, 0x9d,
            0x9e, 0x9d, 0x00, 0x82, 0xc1, 0xc5, 0xc6, 0xc5, 0xc6, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0xe7, 0xb1,
            0x63, 0x00
        ];

        // Test: AllZeros - All zero data (16 vertices, stride 4)
        private static readonly byte[] kVertexAllZerosExpected = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        ];

        private static readonly byte[] kVertexAllZerosData = [
            0xa1, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];

        // Test: Alternating - 0/255 alternating pattern (16 vertices, stride 4)
        private static readonly byte[] kVertexAlternatingExpected = [
            0, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 0, 255, 0, 0, 255,
            0, 255, 255, 0, 255, 0, 255, 0, 0, 255, 0, 255, 255, 0, 255, 0,
            0, 255, 255, 0, 255, 0, 0, 255, 0, 255, 255, 0, 255, 0, 255, 0,
            0, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 0, 255, 0, 0, 255
        ];

        private static readonly byte[] kVertexAlternatingData = [
            0xa1, 0x55, 0x01, 0x19, 0x99, 0x99, 0x99, 0x01, 0x26, 0x66, 0x66, 0x66, 0x01, 0x12, 0x49, 0x24,
            0x92, 0x01, 0x21, 0x86, 0x18, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00
        ];

        // Test: HighBase - High base values with small deltas (16 vertices, stride 8, ushort)
        private static readonly ushort[] kVertexHighBaseExpected = [
            60000, 50000, 40000, 30000, 60001, 50002, 40001, 30003, 60002, 50004, 40002, 30006, 60003, 50006, 40003, 30009,
            60004, 50008, 40004, 30012, 60005, 50010, 40005, 30015, 60006, 50012, 40006, 30018, 60007, 50014, 40007, 30021,
            60008, 50016, 40008, 30024, 60009, 50018, 40009, 30027, 60010, 50020, 40010, 30030, 60011, 50022, 40011, 30033,
            60012, 50024, 40012, 30036, 60013, 50026, 40013, 30039, 60014, 50028, 40014, 30042, 60015, 50030, 40015, 30045
        ];

        private static readonly byte[] kVertexHighBaseData = [
            0xa1, 0x99, 0x99, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x04, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
            0x44, 0x01, 0x2a, 0xaa, 0xaa, 0xaa, 0x02, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xea, 0x50,
            0xc3, 0x40, 0x9c, 0x30, 0x75, 0x00, 0x00
        ];

        // Test: Sawtooth - Up/down sawtooth pattern (16 vertices, stride 4)
        private static readonly byte[] kVertexSawtoothExpected = [
            0, 10, 20, 30, 30, 40, 50, 60, 60, 70, 80, 90, 90, 100, 110, 120,
            90, 100, 110, 120, 60, 70, 80, 90, 30, 40, 50, 60, 0, 10, 20, 30,
            0, 10, 20, 30, 30, 40, 50, 60, 60, 70, 80, 90, 90, 100, 110, 120,
            90, 100, 110, 120, 60, 70, 80, 90, 30, 40, 50, 60, 0, 10, 20, 30
        ];

        private static readonly byte[] kVertexSawtoothData = [
            0xa1, 0x55, 0x00, 0xee, 0xee, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b,
            0x3b, 0x00, 0xee, 0xee, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b,
            0x00, 0xee, 0xee, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x00,
            0xee, 0xee, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0a, 0x14, 0x1e, 0x00
        ];


        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexBitGroups()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexBitGroupsData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexBitGroupsExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexBitGroupsSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexBitGroupsData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexBitGroupsExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexBitGroupSentinels()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexBitGroupSentinelsData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexBitGroupSentinelsExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexBitGroupSentinelsSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexBitGroupSentinelsData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexBitGroupSentinelsExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexDeltas()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexDeltasData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, ushort>(decoded).ToArray(), Is.EqualTo(kVertexDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexDeltasSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexDeltasData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, ushort>(decoded).ToArray(), Is.EqualTo(kVertexDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexBitXor()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 16, kVertexBitXorData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, uint>(decoded).ToArray(), Is.EqualTo(kVertexBitXorExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexBitXorSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 16, kVertexBitXorData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, uint>(decoded).ToArray(), Is.EqualTo(kVertexBitXorExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexLarge()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(128, 4, kVertexLargeData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexLargeExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexLargeSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(128, 4, kVertexLargeData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexLargeExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexSmall()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(13, 4, kVertexSmallData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexSmallExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexSmallSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(13, 4, kVertexSmallData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexSmallExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexNegativeDeltas()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexNegativeDeltasData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, short>(decoded).ToArray(), Is.EqualTo(kVertexNegativeDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexNegativeDeltasSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexNegativeDeltasData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, short>(decoded).ToArray(), Is.EqualTo(kVertexNegativeDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexMixedDeltas()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexMixedDeltasData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, short>(decoded).ToArray(), Is.EqualTo(kVertexMixedDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexMixedDeltasSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexMixedDeltasData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, short>(decoded).ToArray(), Is.EqualTo(kVertexMixedDeltasExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexHighRotation()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 16, kVertexHighRotationData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, uint>(decoded).ToArray(), Is.EqualTo(kVertexHighRotationExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexHighRotationSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 16, kVertexHighRotationData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, uint>(decoded).ToArray(), Is.EqualTo(kVertexHighRotationExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexSparsePattern()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexSparsePatternData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexSparsePatternExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexSparsePatternSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexSparsePatternData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexSparsePatternExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexAllZeros()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexAllZerosData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexAllZerosExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexAllZerosSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexAllZerosData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexAllZerosExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexAlternating()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexAlternatingData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexAlternatingExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexAlternatingSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexAlternatingData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexAlternatingExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexHighBase()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexHighBaseData, useSimd: false);
            Assert.That(MemoryMarshal.Cast<byte, ushort>(decoded).ToArray(), Is.EqualTo(kVertexHighBaseExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexHighBaseSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 8, kVertexHighBaseData, useSimd: true);
            Assert.That(MemoryMarshal.Cast<byte, ushort>(decoded).ToArray(), Is.EqualTo(kVertexHighBaseExpected));
        }

        [Test]
        [Category("Vertex Decoder")]
        public void DecodeVertexSawtooth()
        {
            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexSawtoothData, useSimd: false);
            Assert.That(decoded, Is.EqualTo(kVertexSawtoothExpected));
        }

        [Test]
        [Category("Vertex Decoder SIMD")]
        public void DecodeVertexSawtoothSimd()
        {
            if (!MeshOptimizerVertexDecoder.IsHardwareAccelerated)
            {
                Assert.Ignore("Vector128 is not hardware accelerated.");
            }

            var decoded = MeshOptimizerVertexDecoder.DecodeVertexBuffer(16, 4, kVertexSawtoothData, useSimd: true);
            Assert.That(decoded, Is.EqualTo(kVertexSawtoothExpected));
        }
    }
}
